npm init, so dependencies are installable
express mongoose passport passport-jwt jsonwebtoken body-parser bcryptjs validator  ..
$ npm i -D nodemon as Dev dependencies, with it no need to restart server after every change
server after created in localhost:5000

in package.json under scripts are the start commands for the server.js SO RUNING FROM THE CONSOLE WE CAN ACCESS MORE WAYS TO START SERVER.js IN DIFFERENT WAYS
npm start = classic way, npm run server     starts the nodemon way, changes ares shown after saving

FOR NOT HAVE THE ROUTES ON SERVER.js , a folder with routes has all that
config has the keys, -- for mongo etc...

users.js has to do with autentication , profile all stuff in the site.
.. the routes are used in the server.js   ROUTES ARE MANAGIG THE JSON 

USING EXPRESS routers to us more files one for each resources, (users, posts ,profile) .. 

//THE PORPOSE OF THE BACKEND  AND ROUTES::: IS SERVING JSON TO PICK FROM TEH FRONTEND

//@route GET api/users
//@description Get all
//@access Public

 ssl in gitbash has given problems of security, reinstalled git with standard windows whatitis

if the access is private for example for people logged in
they need a jsonwebtoken to use to log in

after routes are there a schema is created in models,
every resource needs a schema 

in api/users.js the password get encrypted and an avatar get searched
webtoken  w/ passport and passport jwt
json webtoken module creates the token, passport will validate and extract the users informations from it

password should be validated,
- see bcrypt.compare()
in Login teh email get checked, if there is the user, the jwt (imported from ('jsonwebtoken'))
in addition needed is the line:  require("../../config/passport")(passport);
so that ;   const passport = require("passport");       knows the strategy created in the file passport
... if the email there is = registered user, User.findOne gives back the obeject with the email matching
with it will be pulled out further informations from the object to create a payload for the jwt.sign()
jwt.sign takes: payload, secret or key(imported), expiration time as an object, and a callback function
with the error and token as parameter, we send back the res.json {boolean: true, token: "Bearer " + token}

once the succeful match is ok gives us a token, nedded is to implement passportt verify the token and make the route private
pssport has a lot of authentication strategy.. jwt is one, passport is the MAIN AUTHENTICATION MODULE.

for it in server js we need to import passport and before the routes are used:
app.use(passport.initialize()) and require("../../config/passport")(passport);

in tthe config/passport wil be implemented something like: https://github.com/themikenicholson/passport-jwt
opts.audience, opts.ssuer dont needed..
ExtractJwt permit to extract the userdata as payload to use..
with passport.use(new JwtStrategy) takes opts and a callback including the payloadwith the user data, once it is therewe need to 
find the user and validate it... see passport.js
passport: 1 get initialized in the server.js a strategy is created in passport.js and imported

the strategy is used in a protected route,
passport let us make protected routes, see /current
accessing current, we need to send the same token, got with the login, as header (as key)"Authorisation"
with the request.   the jwt strategy we can get the payload for jwt.
User.findById() mongoose method..  ( jwt_payload.id ) jwt_payload is an object with the jwt datas,
whith it, in this case id name avatar iat(issued at),and exp.. iration. in seconds
.. in jwt srtrategy if searching for id user is found we return the function done 

--- the user is enbedded in the token.. when we login

everytime hitting /current we need to send the jwt token as header, got from the login

finished the strategy in /current.. for ex if :  res.json(req.user); gives back:    {
    "date": "2018-11-02T22:48:05.949Z",
    "_id": "5bdcd511f80cf020c0a8204e",
    "name": "First Registration",
    "email": "firstregistration@yahoo.com",
    "avatar": "//www.gravatar.com/avatar/d71035d91d9a5eb6808a592c010ffd2d?s=200&r=pg&d=mm",
    "password": "$2a$10$xkuey/.cSXekbQO7RHeS1.e4YZL/oNBHMKnlhZuTjtKWo4RRdVf4y",
    "__v": 0                                                             }
    is not good to have also password back for ex then can be sent just user.id .email .something but not password or private stuff ;)
ALL TOGETHER: LOGGED IN - GOT TOKEN - TRY TO ACCESS WHITOUT TOKEN IS UNOUTORIZED;
ADDING THE TOKEN IS RESPONDING WITH THIS USER OBJ

... needed is more validation .. for the words given in the form for the login.. kid of regex stuff
making a function.
validator module is validating a string.. see Validator in: https://github.com/chriso/validator.js/
..but has to be a string .
 made validateRegistrtionInput(data)  and inserted that in the frst lines when the user logs in router.get(/register)

every fild taking data will be pased fisrt to see if the form data sent are the right format, for that there areall the file
in the validation direcotry..

those checks will be applied for the dataform methods..

PROFILE.
- a Schema for the profiles is in models. in the profile for example the user can add many comma separated values 
for that in the schema are array for those fields

first rout protected that will get the current user profile..
for to get the profile at route profile/ the token puts the user object in the req.user
***  the mongoose method find one searches in the Profile schema an user with the id given.. id is in the token..
as payload when the user logs in     searching in the Profile schema to get all the profile informations
-- Like in the users routes taking datas is initialized an error object to collect all the issues..
-- /profile if there is no profile associated with this user (per id...), and the table in the db with the schema
profile does not have this user we get back no user found, as it is everytime when one user want to search for the profileand there isn't any
--- this part: just go to the route with the token, token puts the fetched user object (if token valid) in res.user , 
using Profile.findOne({user: req.body.id}), db watches the profile schema, it takes an id, searches if there is a profile
in the Profile schema with such id and if found gives back an object with the fields of the profile that has this id..
.. when a user creates a profile the profile datas have the same id of the user in the user table..
...2 DB tables one id .. yeah.. 


TO CREATE A PROFILE THE URL IS THE SAME /profile BUT  WITH THE POST method..
we get the id from the token payload of the user and set to that id.. Profile.findOne({ user: req.user.id })

.. when someone want to create the profile POST at /profile fill the filds and save it to the db
!!!!!       THE POST METHOD IN THE ROUTE /profile CAN CREATE OR UPDATE A PROFILE FO ALREADY CREATED ONE.
.. so: get everithing in re. body fill the filds, then search for the user just update if not see if the handle there is send an error if handle free save and give back the profile saved

like the other routes taking datas the one for the profile validaes first the required datas then loads all other fields,
and goes searching for create new checking if the handle exists already or update other.. 
if everything is ok sends back the infos... 
when a profile is created in the database the colloction profile has only one table the one for the registrated users that hasve a profile

if we send a POST request to the /profile  it updates the required fields and the other filled out and gives back 
this saved record in the DB
{
    "skills": [
        "Assembly",
        "Swim",
        "Catching the tiket before is sold out"
    ],
    "_id": "5bdf4078c16fe71f50298d55",
    "user": "5bdcd511f80cf020c0a8204e",
    "handle": "firstregistration",
    "status": "single",
    "experience": [],
    "infos": [],
    "date": "2018-11-04T18:54:48.092Z",
    "__v": 0,
    "job": "job center office",
    "website": "http://www.google.com"
}
@ POST /profile
 profileFields.user = req.user.id;
in schema,  user:   needs the ID of the user logged in, and validate with token, that makes the profile       (or updates)....
 ..in the strategy  the jwt payload has the datas of the user in req.user
    
    User.findById(jwt_payload.id)   config/passport file

    if the token findthe user at login get as payload the id of the user object automatically created from DB for this user
    , the field user in the schema Profiles takes the id of the user who is logged in,
    so it knows which user has that profile.. from the id..

here we take only the id of the user who has this token, this is the only info of the user bound with the table profile

---  profile created yeah! 
to access to the profile, the token validates the acces and gives back to the client the obj with all the things filled of type ProfileSchema
@ get /profile
 return res.json(profileObj);..  this has all the filds of the profile but no user information..

...SINCE :::::  
const ProfileSchema = new Schema({
  user: {
    type: Schema.Types.ObjectId, //associate the user by its id,
    ref: "users"
  } ....
                ::::::: IN THE GET METHOD FETCHING THE USER 
                we are able to populate fields of the 'users' 

Profile.findOne({ user: req.user.id })
      .populate('user',['name','avatar']) /// adding this line in the response we get the filds of "users" for this user together with the response..
      .then(profileObj => {       but .....      ..always..
        if (!profileObj) {   only...                       ...if   ...  ...........

so we enbed the name avatar of the model User in the response fetching in the model Profile.. so we have them as well going to
/get with one token..
WITH IT GOING TO GET /profile we receive back that
{
    "skills": [
        "Assembly",
        "Swim",
        "Catching the tiket before is sold out"
    ],
    "_id": "5bdf4078c16fe71f50298d55",
    "user": {
        "_id": "5bdcd511f80cf020c0a8204e",
        "name": "First Registration",
        "avatar": "//www.gravatar.com/avatar/d71035d91d9a5eb6808a592c010ffd2d?s=200&r=pg&d=mm"
    },
    "handle": "firstregistration",
    "status": "single",
    "experience": [],
    "infos": [],
    "date": "2018-11-04T18:54:48.092Z",
    "__v": 0,
    "job": "job center office",
    "website": "http://www.google.com"
}

routes for infos and experiences are a bit different because those types are arrays
-first a check for requested fields, then findOne, in Profile Schema search where the field user has the id of the req.user,
searches the right id of this logged in user in the table Profile, finding a metching profile,
creating an object, filling it with all the fields in the form, and unshift this object in the array profile.infos
Profile.findOne({ user: req.user.id }).then(profile => { .... ....  ... profile.infos.unshift(newInfo); new info is the object created ..={a:1,b:2, ...}

routes experiences and infos have theitr own route to fill the array field, part of the profile object
- they are updating the array and save it back to teh DB

adding experiences and infos is also handy to have delete them, or delete profile and all..

trying with filter i had ab bad time to remove an item from the array, then first is needed to findthe index and then act on the array directly
, so just saving back the same array less the selected item..
