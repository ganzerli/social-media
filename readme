npm init, so dependencies are installable
express mongoose passport passport-jwt jsonwebtoken body-parser bcryptjs validator  ..
$ npm i -D nodemon as Dev dependencies, with it no need to restart server after every change
server after created in localhost:5000

in package.json under scripts are the start commands for the server.js SO RUNING FROM THE CONSOLE WE CAN ACCESS MORE WAYS TO START SERVER.js IN DIFFERENT WAYS
npm start = classic way, npm run server     starts the nodemon way, changes ares shown after saving

FOR NOT HAVE THE ROUTES ON SERVER.js , a folder with routes has all that
config has the keys, -- for mongo etc...

users.js has to do with autentication , profile all stuff in the site.
.. the routes are used in the server.js   ROUTES ARE MANAGIG THE JSON 

USING EXPRESS routers to us more files one for each resources, (users, posts ,profile) .. 

//THE PORPOSE OF THE BACKEND  AND ROUTES::: IS SERVING JSON TO PICK FROM TEH FRONTEND

//@route GET api/users
//@description Get all
//@access Public

 ssl in gitbash has given problems of security, reinstalled git with standard windows whatitis

if the access is private for example for people logged in
they need a jsonwebtoken to use to log in

after routes are there a schema is created in models,
every resource needs a schema 

in api/users.js the password get encrypted and an avatar get searched
webtoken  w/ passport and passport jwt
json webtoken module creates the token, passport will validate and extract the users informations from it

password should be validated,
- see bcrypt.compare()
in Login teh email get checked, if there is the user, the jwt (imported from ('jsonwebtoken'))
in addition needed is the line:  require("../../config/passport")(passport);
so that ;   const passport = require("passport");       knows the strategy created in the file passport
... if the email there is = registered user, User.findOne gives back the obeject with the email matching
with it will be pulled out further informations from the object to create a payload for the jwt.sign()
jwt.sign takes: payload, secret or key(imported), expiration time as an object, and a callback function
with the error and token as parameter, we send back the res.json {boolean: true, token: "Bearer " + token}

once the succeful match is ok gives us a token, nedded is to implement passportt verify the token and make the route private
pssport has a lot of authentication strategy.. jwt is one, passport is the MAIN AUTHENTICATION MODULE.

for it in server js we need to import passport and before the routes are used:
app.use(passport.initialize()) and require("../../config/passport")(passport);

in tthe config/passport wil be implemented something like: https://github.com/themikenicholson/passport-jwt
opts.audience, opts.ssuer dont needed..
ExtractJwt permit to extract the userdata as payload to use..
with passport.use(new JwtStrategy) takes opts and a callback including the payloadwith the user data, once it is therewe need to 
find the user and validate it... see passport.js
passport: 1 get initialized in the server.js a strategy is created in passport.js and imported

the strategy is used in a protected route,
passport let us make protected routes, see /current
accessing current, we need to send the same token, got with the login, as header (as key)"Authorisation"
with the request.   the jwt strategy we can get the payload for jwt.
User.findById() mongoose method..  ( jwt_payload.id ) jwt_payload is an object with the jwt datas,
whith it, in this case id name avatar iat(issued at),and exp.. iration. in seconds
.. in jwt srtrategy if searching for id user is found we return the function done 

--- the user is enbedded in the token.. when we login

everytime hitting /current we need to send the jwt token as header, got from the login

finished the strategy in /current.. for ex if :  res.json(req.user); gives back:    {
    "date": "2018-11-02T22:48:05.949Z",
    "_id": "5bdcd511f80cf020c0a8204e",
    "name": "First Registration",
    "email": "firstregistration@yahoo.com",
    "avatar": "//www.gravatar.com/avatar/d71035d91d9a5eb6808a592c010ffd2d?s=200&r=pg&d=mm",
    "password": "$2a$10$xkuey/.cSXekbQO7RHeS1.e4YZL/oNBHMKnlhZuTjtKWo4RRdVf4y",
    "__v": 0                                                             }
    is not good to have also password back for ex then can be sent just user.id .email .something but not password or private stuff ;)
ALL TOGETHER: LOGGED IN - GOT TOKEN - TRY TO ACCESS WHITOUT TOKEN IS UNOUTORIZED;
ADDING THE TOKEN IS RESPONDING WITH THIS USER OBJ

... needed is more validation .. for the words given in the form for the login.. kid of regex stuff
making a function.
validator module is validating a string.. see Validator in: https://github.com/chriso/validator.js/
..but has to be a string .
 made validateRegistrtionInput(data)  and inserted that in the frst lines when the user logs in router.get(/register)

every fild taking data will be pased fisrt to see if the form data sent are the right format, for that there areall the file
in the validation direcotry..

those checks will be applied for the dataform methods..

PROFILE.
- a Schema for the profiles is in models. in the profile for example the user can add many comma separated values 
for that in the schema are array for those fields

first rout protected that will get the current user profile..
for to get the profile at route profile/ the token puts the user object in the req.user
***  the mongoose method find one searches in the Profile schema an user with the id given.. id is in the token..
as payload when the user logs in     searching in the Profile schema to get all the profile informations
-- Like in the users routes taking datas is initialized an error object to collect all the issues..
-- /profile if there is no profile associated with this user (per id...), and the table in the db with the schema
profile does not have this user we get back no user found, as it is everytime when one user want to search for the profileand there isn't any
--- this part: just go to the route with the token, token puts the fetched user object (if token valid) in res.user , 
using Profile.findOne({user: req.body.id}), db watches the profile schema, it takes an id, searches if there is a profile
in the Profile schema with such id and if found gives back an object with the fields of the profile that has this id..
.. when a user creates a profile the profile datas have the same id of the user in the user table..
...2 DB tables one id .. yeah.. 


TO CREATE A PROFILE THE URL IS THE SAME /profile BUT  WITH THE POST method..
we get the id from the token payload of the user and set to that id.. Profile.findOne({ user: req.user.id })

.. when someone want to create the profile POST at /profile fill the filds and save it to the db
!!!!!       THE POST METHOD IN THE ROUTE /profile CAN CREATE OR UPDATE A PROFILE FO ALREADY CREATED ONE.
.. so: get everithing in re. body fill the filds, then search for the user just update if not see if the handle there is send an error if handle free save and give back the profile saved

like the other routes taking datas the one for the profile validaes first the required datas then loads all other fields,
and goes searching for create new checking if the handle exists already or update other.. 
if everything is ok sends back the infos... 
when a profile is created in the database the colloction profile has only one table the one for the registrated users that hasve a profile

if we send a POST request to the /profile  it updates the required fields and the other filled out and gives back 
this saved record in the DB
{
    "skills": [
        "Assembly",
        "Swim",
        "Catching the tiket before is sold out"
    ],
    "_id": "5bdf4078c16fe71f50298d55",
    "user": "5bdcd511f80cf020c0a8204e",
    "handle": "firstregistration",
    "status": "single",
    "experience": [],
    "infos": [],
    "date": "2018-11-04T18:54:48.092Z",
    "__v": 0,
    "job": "job center office",
    "website": "http://www.google.com"
}
@ POST /profile
 profileFields.user = req.user.id;
in schema,  user:   needs the ID of the user logged in, and validate with token, that makes the profile       (or updates)....
 ..in the strategy  the jwt payload has the datas of the user in req.user
    
    User.findById(jwt_payload.id)   config/passport file

    if the token findthe user at login get as payload the id of the user object automatically created from DB for this user
    , the field user in the schema Profiles takes the id of the user who is logged in,
    so it knows which user has that profile.. from the id..

here we take only the id of the user who has this token, this is the only info of the user bound with the table profile

---  profile created yeah! 
to access to the profile, the token validates the acces and gives back to the client the obj with all the things filled of type ProfileSchema
@ get /profile
 return res.json(profileObj);..  this has all the filds of the profile but no user information..

...SINCE :::::  
const ProfileSchema = new Schema({
  user: {
    type: Schema.Types.ObjectId, //associate the user by its id,
    ref: "users"
  } ....
                ::::::: IN THE GET METHOD FETCHING THE USER 
                we are able to populate fields of the 'users' 

Profile.findOne({ user: req.user.id })
      .populate('user',['name','avatar']) /// adding this line in the response we get the filds of "users" for this user together with the response..
      .then(profileObj => {       but .....      ..always..
        if (!profileObj) {   only...                       ...if   ...  ...........

so we enbed the name avatar of the model User in the response fetching in the model Profile.. so we have them as well going to
/get with one token..
WITH IT GOING TO GET /profile we receive back that
{
    "skills": [
        "Assembly",
        "Swim",
        "Catching the tiket before is sold out"
    ],
    "_id": "5bdf4078c16fe71f50298d55",
    "user": {
        "_id": "5bdcd511f80cf020c0a8204e",
        "name": "First Registration",
        "avatar": "//www.gravatar.com/avatar/d71035d91d9a5eb6808a592c010ffd2d?s=200&r=pg&d=mm"
    },
    "handle": "firstregistration",
    "status": "single",
    "experience": [],
    "infos": [],
    "date": "2018-11-04T18:54:48.092Z",
    "__v": 0,
    "job": "job center office",
    "website": "http://www.google.com"
}

routes for infos and experiences are a bit different because those types are arrays
-first a check for requested fields, then findOne, in Profile Schema search where the field user has the id of the req.user,
searches the right id of this logged in user in the table Profile, finding a metching profile,
creating an object, filling it with all the fields in the form, and unshift this object in the array profile.infos
Profile.findOne({ user: req.user.id }).then(profile => { .... ....  ... profile.infos.unshift(newInfo); new info is the object created ..={a:1,b:2, ...}

routes experiences and infos have theitr own route to fill the array field, part of the profile object
- they are updating the array and save it back to teh DB

adding experiences and infos is also handy to have delete them, or delete profile and all..

trying with filter i had ab bad time to remove an item from the array, then first is needed to findthe index and then act on the array directly
, so just saving back the same array less the selected item..

/////////////7   J  U  S   T                       R   E  M  E  M     B  E  R 

JWT PUTS THE USER IN THE REQUEST ::: A CONSOLE:LOG OF REQ

 body:
   { text: 'this post has only the text.. lets see how is the db' },
  _body: true,
  length: undefined,
  _passport:
   { instance:
      Authenticator {
        _key: 'passport',
        _strategies: [Object],
        _serializers: [],
        _deserializers: [],
        _infoTransformers: [],
        _framework: [Object],
        _userProperty: 'user',
        _sm: [SessionManager],
        Authenticator: [Function: Authenticator],
        Passport: [Function: Authenticator],
        Strategy: [Function],
        strategies: [Object] } },
  route:
   Route {
     path: '/',
     stack: [ [Layer], [Layer] ],
     methods: { post: true } },
  user:
   { date: 2018-11-02T22:48:05.949Z,
     _id: 5bdcd585f80cf020c0a8204f,
     name: 'Second Registration',
     email: 'secondregistration@yahoo.com',
     avatar:
      '//www.gravatar.com/avatar/23ebedb1e55447af6a00bb136bd6fda1?s=200&r=pg&d=mm',
     password:
      '$2a$10$DtyMUMeatD9SUFH87ptFBOI8MeqjrnJ/tcR1rZFAYYUnLhPeHylua',
     __v: 0 },
  authInfo: {} }



//////   P  O   S   T 

    POSTS   has a own schema in the models
    -- see the in posts.js the new Post from the post schema.. name and avatr and user are from the body, in react with rdux will be pulled this datas from the strategy
... this is a nice method..
router.delete(
  "/:id",
  passport.authenticate("jwt", { session: false }),
  (req, res) => {
    Profile.findOne({ user: req.user.id }).then(profileFound => {
      // we needto chech that hiitng this route the user deleting is the user of the post
      Post.findById(req.params.id)
        .then(post => {
          if (post.user.toString() !== req.user.id) {
            return res.status(401).json({
              noautorization: "user is not autorized..   calling the cops..."
            });
          }
          post.remove().then(() => res.status(404).json({ success: true }));
        })
        .catch(err => res.status(404).json({ postnotfound: "POST NOT FOUND" }));
    });
  }
);


..LIKES HAVE A ROUTE TO HIT THE LIKES AND ASO TO REMOVE them
.. posts routes are tricky but also heavely commented..


the POSTSCAN BE COMMENTED::
and comment deleted, for to delete acomment is needed the post id to search it and then the id of the comment to remove
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
            B   A    C   K       E    N    D          D    O    N   E        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
============================}}>   PROCEEDING TO         F    R    O    N    T            E  N   D
--------------------------------------------------------------------------------------------------------------------------------------------------------------------


to access to the routes of the backend more easly in the package. json a "proxy" value is added
concurrentyly is installed as dependencie in the root folder, server..
in the package.json a scriüt is added in "scripts" , to direcly lounch the app when deployed and cloned the user donesnt have to
go to the folder client, in the scripts i package.json a client-install field is created. so to go in the folder first and start with one command

if one want to just run the client there is too and dev is for concurrentyly to run both server and client

router is imported in the app main component and the links components point to the specified routes with route components in main app component
component form and register ar set up so that the events are right 
onSubmit an onChange

axios !! in the route taken by axios of register from the post method give us the  .then(userCreated => res.json(userCreated)) 
so we can address on it in front end by axoios as res.data
catch error also in axios front end. with  proxy http500 is skipped
!!! WITH CLASSNAMES package WE CAN HAVE CONDITIONAL CLASSNAMES  !!!
classnames("form-control form-control-lg", {
                        "is-invalid": errors.name
                      })
                      /*the class is-invalid only if there is a errors.name */
with classnames we can give conditioonal classames,
the errors var is created from the state, and the sate get updtated with the response got from the backend, if the response gives a . name

 const { errors, isValid } = validateRegistrationInput(req.body)
  return res.status(400).json({ errors });

  !! THE CUSTOM ERROS CAN BE USED HERE !!
   console.log(err.response.data); we can se the errors
   ------------------------------------------------------
   {errors: {…}}
errors:
email: "email field is required"
name: "the field name is required"
password: "password field is required"
  THIS IS THE RESPONSE OF THE CONSOLE
  --------------------------------------------------------
  
  in jsx in register : 
  {errors.name && (
<div className="invalid-feedback">{errors.name}</div>)}
   ------- under the -->  className={..classnames("fo...}
 classnames("form-control form-control-lg", {
                        "is-invalid": errors.password
                      })
--redux:
the store exists as sonn is
const store = createStore(()=>[],{},applyMidleware());
like that does not throw an error.

ACTIONS redux is all ACTIONS
IF WE WANT TO DISAPTCH AN SOMETHING TO THE REDUCER; ACTION WE CAN SIMPLY RETURN AN OBJECT THAT  M U S T    H A V E    A    T Y P E
THE FUNCTION IN ACTIONS IS AN ACTIN CREATOR.

the action can be called for example in submit,
exporting the component in for redux we have to bind the action andthe map state to props..
the actin can be called also without the map>State to props..
and the state in redux cev tools get updated.
once the form is  submitted if an errors comes back handy is to have an errors reducer
-- in the component must be brought in the 
brought in the root reducer the error reducer, we cn get errors from props
action calls dispatch, in axios, in case of errors it dispatch the error object to the root reducer with a type of GET_ERR, the errReducer takes in the GET_ERR type and returns the payload to the state... the state get updated and so we can use it pulling it from the props in the front end..
a bit more asynch is also use component will receive props method which runs at that time,
the error action can be put there so if the props coming from the state have an err object
we can diplay it after the form is submit
with the errors we can hold them in the component state so that the form works as it was before


in the compnent is imported  with router and bound in the connect part  exporting, 
in the action and in the acition call is needed to addd the this.props.history taht we can put as second paramenter in the action call so in the action if success the page will be redirected to the specific page page we give  


we need to store the token in the local storage
-- WITH AXIOS WE CAN S SET A TOKEN AND USE IT FOR EVERY REQUEST IN PROTECTED ROUTES

see      setAuthToken()   and setAuthToken.js 
the token has the infos of the user, to decode that jwt token, install
npm in the client npm install jwt-decode

the token is decoded and sent to the reducer, the reducer takes the datas inside and uüdates the state, if success then we are redirect to the dashboard, to keep the state also with page refresh in the app. js is a bit the same like the registration, but checks in the local storage, if there is then sets it as header and dispatches the action to update the user state and the isvalid of the auth reducer...
.. log out

the navbar should use redux so to show the right options
the components which has to do with the access are not accessible if the user is logged insee the componentwillReceiveProps,see login js and or landing.
input filds are put inside of custom components..

the input fiellds are cut out and put in a custom component that takes the propertyes for the input a function on change and the right eror to show in the formin case

follow up in profile reducer to remember well..
profile in reducers and imported in the root reducer, after created base profile reducer type and action get created, in profile action will be 
get current profile just dispatcehes the type and the profile object, if there is no profile for this user the object is empty
sot  that in case the user can make a profile from there.. the reducer when the action is there sets loading back again and the profile  to the state
 a dashboard dierctory is in the component the first part dashboard.js is imported in app js as route

 THE CLEARcURRENT profile get called to log out and the user object in the state get set back to null-
 !! ONLY IF LOGGING IN NO PROFILE IN THE DB,  THE PROFILE OBJECT WILL BE AN EMPTY OBJECT
 !! ONLY IN LOG OUT THE PROFILE OBJECT GET SET TO NULL AGAIN:
 clearCurrentProfile should is not only inthe navbar but also in ap.js to check if the user has the token in the localtorage..
 so if the token is expired the profile is bak to null

 in the dashboard when componentDidMount we need the user from the auth reducer and the profile from the profileRedicer
 -- Object.keys(profile).length > 0    to see if an objec tis empty

 .... if  the someone tryes to accss a private route then we have to manage first that

 in the create profile.js all the input are cistom component that takes the props to get the part of conditional class away and have all more understandable
 .. once the submit is hit the createprofile action takes the data and also the - history - to redirect to anpther page
 the component hosting that capability must be bound with with router at the export

EDIT PROFILE: has a file in the components /edit-profile/EditProfile.js
edit form will be same as ! ! ! ! -->>> CreatePorofile <<<<--- ! ! ! ! !but the fields that are already written in are automatically filled

!! THE ROUTE IN THE BACKEND ACCEAP REQUESTS FOR CREATE AND UPDATE PROFILE IN THE SAME ROUTE
    Profile.findOne({ user: req.user.id })
      .then(profileObj => {
        if (profileObj) {  ///=====>> if searching in the db for this user id in the profiles and there is just update..
          //UPDATE
          Profile.findOneAndUpdate(
            { user: req.user.id },
            { $set: profileFields },
            { new: true }
          ).then(profileUpdated => res.json(profileUpdated));
        } else {
          //CREATE
          //check if the handle aready exists
          Profile.findOne({ handle: profileFields.handle })
            .then(profileObj => {
              if (profileObj) {
                // if there is a profile in the table-(collection), that has the same handle of the request..
                errors.handle = "handle already exists";
                return res.status(400).json(errors); // any validation errors 400
              } else {
                //if does not exist
                new Profile(profileFields)
                  .save()
                  .then(profileSaved => res.json(profileSaved));   .............................

in EditProfile we need to bring in the getCurrentProfile action.. to rn in the componentDidMount as the most ajax calls

... every page showing must be imported in the App.js with the router so we have the route available , this with switch like the others (protected)
            <Switch>
              <PrivateRoute
                exact
                path="/edit-profile"
                component={EditProfile}
              />
            </Switch>

            so it has a route

for everyp  field in the edit profile we need to see if un the state there is an object profile get the infos from all that fields
and if they are nothing put have them an empty string

AddExperiences when submit it redirects so it needs with router, and to see if somethinfg is already there the profile so we can check for the experiences
-- experiences in the db and in the server are array
the checkbox when checked toggles the state of disabled for the field to and the state of if the checkbox is checked itself
---onCheck(e) {
    this.setState({
      disabled: !this.state.disabled,
      current: !this.state.current
---});}

like every form this will  when submit call the redux action that hit the apy crreated and add the fields in the db.. as array
will be called when the form is submit, thre we need to get the data from the state.

 this.props.addExperiences(experiencesData,this.props.history());     ===>> calling the action, received from props imorted and given to connect,
 we need to pass in the this.props.history() so we can dispatch and redirect in the action directly
 --    THIS IS THANKS TO WITH ROUTER ---  so we just import, attach to the connect, and in the run of the action we can redirect 

 so we can do in the action:
   axios
    .post("/api/profile/experiences")
    .then(res => history.push("/dashboard"));

// the route for the infos is a kind of the same like the speriences.
finished the forms we can show the eperiences in the dashboard
to show the components handling the experiences we make a custom one and we pass the infos ready in the state, because profile is already there

in the dashboard we already have -->  const { profile, loading } = this.props.profile;
we can pass that as prop to the component <Experiences expArray={profile.experiences}/>
this component will take the array and make a table with th data in it.

in <Experiences/> we need withRouter because once deleted an experience there is a redirect to dashboard
Moment package is a library to treat date

the button get the id from the map function, deleteExperience action calls GET_PROFILE, so first is deleted, then we just get the new profile from the response, we dispatch the GET_PROFILE just to update the state after deleting.  ... AMAZING ...

for the infos is kind of the same

--- TO SEE ALL PROFILES A ROUTE TO PROFILES STAY NOT PROTECTED AND A PROFILES COMPONENT IS made
calling the action getAllProfiles we get all profiles as an array , if an error comes we call the same action that set the state of profiles in th
e profile reducer but sending an empty object as payload.. so in the /profiles the Profile component sayes just no profiles